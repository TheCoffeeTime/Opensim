using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using log4net;
using OpenSim.Region.Framework.Scenes;
using OpenSim.Region.Framework.Interfaces;
using System.Reflection;
using OpenMetaverse;
using System.Threading;
using Nini.Config;
using OpenSim.Framework;
using OpenMetaverse.Assets;
using OpenSim.Region.OptionalModules.Example.BareBonesNonShared;
using System.Drawing;
using System.Collections;

/// Author: Mihail Kovachev
/// Author: Mona Demaidi
/// Author: Thanakorn Tuanwachat
namespace OpenSim.Region.OptionalModules.Example.BareBonesNonShared
{
    /// <summary>
    /// Added By Mona
    /// Determine the refractive index of different PrimMaterials
    /// </summary>
    public static class RefrectiveIndex
    {
        public const double STONE = 5;
        public const double METAL = 14;
        public const double GLASS = 1.4;
        public const double WOOD = 4;
        public const double FLESH = 1.3;
        public const double PLASTIC = 1.5;
        public const double RUBBER = 1.5;
        public const double AIR = 1;

        public static double getRefractiveIndex(int material)
        {
            switch (material)
            {
                case 0:
                    return STONE;
                case 1:
                    return METAL;
                case 2:
                    return GLASS;
                case 3:
                    return WOOD;
                case 4:
                    return FLESH;
                case 5:
                    return PLASTIC;
                case 6:
                    return RUBBER;
                case 7:
                    return AIR;
                default:
                    return AIR;
            }
        }
        
    }
    /// <summary>
    /// Shape of an object in the world. (Class is used when drawing an object)
    /// </summary>
    static class PrimType
    {
        public const int Box = 1;
        public const int Sphere = 2;
        public const int Cylinder = 3;
    }
    public class RayTracer
    {
        //m_log: used for outputting message on standard output. 
        //m_prims of objects/entities in the world.
        //hits: Array of List reflections from 0 to MAX_REFLECTIONS. 
        private static readonly ILog m_log = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

        public Scene m_scene=null;                 //scene in the world which contains all the objects in the world 
        public EntityBase[] m_prims;               //array of entity. (This will be used to stored all the entity in the world)
        public IScriptModuleComms m_commsMod;      //Can be used to send message back to the script
        public List<SceneObjectPart> worldObjects; //All objects in the world which its distance to the transmitter < MAX_DISTANCE
        public SceneObjectGroup transmitter;       //Transmitter in the world
        public SceneObjectGroup receiver;          //receiver in the world
        public Dictionary<string, PathFromTxToRy>[] pathHits; //List of List of paths from a transmitter to the reciever.
        //Default Ray tracer variables. These variables will be reset then the "restart ray stacer" button is pressed

        public int MAX_REFLECTIONS = 5;            //Total number of reflection can occur
        public float MAX_DISTANCE = 30;            //The longest length of a single ray (without reflection)
        public int ANGLE_BETWEEN_RAY = 1;          //Angle between any ray (used in BlindSearch/BruteForce method)
        public string runningFreqRT = "2.4";       //Frequency of the radio
        public string runningFreqRTUnit = "ghz";   //Unit of the frequency
        public double runningPowerRT = 44;         //Power generated by the transmitter
        public string runningPowerRTUnit = "dBW";  //Unit of the power generated by the transmitter
        public string RTModel;                     //Receiver model
        public string ANModel;                     //Antenna model. e.g. isotropic, directional etc.
        public UUID scriptID;                      //UUID of the script which called this class.
        public string rayScript;                   //An lsl script for each ray
        public static int rayID;                   //Each ray has a unique id
        public static int pathID;                  //Each path has a unique id
        public static List<Vector3> allRayPos;     //A list of vectors for all ray position. This will be used to check for repition.

        public int noCount = 0;

        double DEG_TO_RAD = Math.PI / 180.0;

        /// <summary>
        /// Initialise all variables needed to be used by this ray tracer model. 
        /// </summary>
        /// <param name="scene">The scene in the world</param>
        /// <param name="setOfvariables">Set of variable values from the remote control</param>
        /// <param name="_scriptID">UUID of the script which called this function</param>
        public void Initialise(Scene scene, string setOfvariables, UUID _scriptID)
        {
            m_scene = scene;
            m_commsMod = m_scene.RequestModuleInterface<IScriptModuleComms>();
            scriptID = _scriptID;

            //Initialise variables parsed from the remote control. 
            int noOfInitVar = initialiseVariables(setOfvariables);
            rayID = 0;
            pathID = 0;
            m_log.DebugFormat("[RAY TRACER INITIALISATION]: total number of initialised variables = " + noOfInitVar.ToString());

            //Get all the entities in the world
            try { m_prims = m_scene.GetEntities(); }
            catch (Exception ex) { }

            //Initialise transmitter and receiver.
            if (!findTransmitterAndReceiver())
            {
                m_log.DebugFormat("[Ray Tracer PostInit] Transmitter and/or receiver not Found!");
                throw new Exception("Cannot find either Transmitter Tx or Receiver Ry");
            }

            //Initialise worldObjects. WorldObjects contains all the parts of the objects in the world which
            //the distance from itself to the transmitter is less than the MAX_DISTANCE. This is to reduce the
            //number of parts that we have to look at, i.e. reduces the computations time to find reflections. 

            worldObjects = new List<SceneObjectPart>();
            for (int i = 0; i < m_prims.Length; i++)
            {
                if (m_prims[i] is SceneObjectGroup)
                {
                    SceneObjectGroup sog = (SceneObjectGroup)m_prims[i];
                    sog.ForEachPart(delegate(SceneObjectPart part)
                    {
                        if (Vector3.Distance(part.AbsolutePosition, transmitter.RootPart.AbsolutePosition) <= MAX_DISTANCE || part.Name.CompareTo("Ry") == 0)
                        {
                            worldObjects.Add(part);
                        }
                    });
                }
            }

            //Read rayScript from a file. (e.g. setting for transparency, phantom, and other touch function etc.)
            rayScript = System.IO.File.ReadAllText(@"C:\Users\Thanakorn\Documents\GitHub\Opensim\scripts\scripts\ray.txt");

            //Initialise pathList for all reflections from 0 to max reflection
            pathHits = new Dictionary<string, PathFromTxToRy>[MAX_REFLECTIONS + 1];
            for (int i = 0; i < MAX_REFLECTIONS + 1; i++)
            {
                pathHits[i] = new Dictionary<string, PathFromTxToRy>();
            }

            allRayPos = new List<Vector3>();
            
            m_log.DebugFormat("[RAY TRACER INITIALISATION]: Complete!");

        }
        /// <summary>
        /// set RayTracer class varaibles according to the given set of variables. 
        /// This set of variables come from the in-world script from the remote control, when "restart raytracer" button 
        /// is pressed. 
        /// </summary>
        /// <param name="setOfVariables"></param>
        public int initialiseVariables(string setOfVariables)
        {
            //Each element will have a format of e.g. Frequency=10, FrequencyUnit=MHz etc.
            string[] arrayOfVariables = setOfVariables.Split('_');
            
            //Check if all the variable has been initialise by counting. 
            int countVariable = 0;
            //Foreach of those element the the variables
            foreach (string variableNameAndValue in arrayOfVariables)
            {
                string[] variableNameAndValueToken = variableNameAndValue.Split('=');
                //if variable has value attatch to it.
                if (variableNameAndValueToken.Length == 2)
                {
                    string variableName = variableNameAndValueToken[0];
                    string variableValue = variableNameAndValueToken[1];
                    switch (variableName)
                    {

                        case "Frequency":
                            runningFreqRT = variableValue;
                            countVariable++;
                            break;

                        case "FrequencyUnit":
                            runningFreqRTUnit = variableValue;
                            countVariable++;
                            break;

                        case "TransmitterPower":
                            runningPowerRT = Convert.ToDouble(variableValue);
                            countVariable++;
                            break;
                        case "TransmitterPowerUnit":
                            runningPowerRTUnit = variableValue;
                            countVariable++;
                            break;
                        case "Model":
                            RTModel = variableValue;
                            countVariable++;
                            break;
                        case "AngleBetweenRays":
                            ANGLE_BETWEEN_RAY = StringAndNumberConversion.getOnlyIntegerNumber(variableValue, ' ');
                            countVariable++; 
                            break;
                        case "AntennaType":
                            ANModel = variableValue;
                            countVariable++;
                            break;
                        case "MaxReflection":
                            MAX_REFLECTIONS = StringAndNumberConversion.getOnlyIntegerNumber(variableValue, ' ');
                            countVariable++;
                            break;
                        case "MaxDistance":
                            MAX_DISTANCE = StringAndNumberConversion.getOnlyIntegerNumber(variableValue, ' ');
                            countVariable++;
                            break;
                        default:
                            //This default is for debugging purpose. If this variable name did not match any of the existing variables name. 
                            string errorMsg = "Error: " + variableName + "did not match one of the variables in ray tracer";
                            m_commsMod.DispatchReply(scriptID, 1, "Error: " + errorMsg, "");
                            m_log.DebugFormat("[RAY TRACER INIT] " + variableName + " did not match one of the variables in ray tracer");
                            break;
                    }//switch
                }//if

                //This else is purely for the purpose of debugging purpose. It only happens when the string doesn't 
                //contain both variable and its value, ie, not in this formar -> var=10, frequency=20
                else

                {
                    string errorMsg = "Error: " + variableNameAndValueToken[0] + "has length != 2";
                    m_commsMod.DispatchReply(scriptID, 1, "Error: " + errorMsg, "");
                }//else
            }//foreach

            return countVariable;
        }
        /// <summary>
        /// </summary>
        public void PostInitialise()
        {
            //For debugging purpose for now
            noCount = 0;
            int noOfElement = 0;
            startRayTracerBrutefoce();

            //Add(if there is any) the line-of-sight and 1-reflections rays into the hit list. 
            DirectMap0Ref();
            DirectMap1Ref();
            
            noOfElement = pathHits[0].Count;
            noOfElement += pathHits[1].Count;
            noOfElement += pathHits[2].Count;
            noOfElement += pathHits[3].Count;
            noOfElement += pathHits[4].Count;
            noOfElement += pathHits[5].Count;

            m_log.DebugFormat("Number of element counted" + noCount);
            m_log.DebugFormat("Number of element in the list" + noOfElement);

            for(int i = 0; i < MAX_REFLECTIONS + 1; i++)
            {
                foreach (KeyValuePair<string, PathFromTxToRy> path in pathHits[i])
                {
                    drawRayPath(path.Value);
                }
            }
        }
        /// <summary>
        /// Find if transmitter and receiver exist by checking all the objects in the world name. 
        /// Transmitter = Tx, Receiver = Ry.
        /// </summary>
        /// <returns></returns>
        public bool findTransmitterAndReceiver()
        {
			try{
            EntityBase[] prims = m_scene.GetEntities();
			
            m_log.DebugFormat("[BARE BONES NON SHARED] Found {0} Entities!", prims.Length);
				
			//For each entities in the world, check if they are a transimitter Tx or a receiver Ry. 
            //Return true if both are true. 
            foreach (EntityBase prim in prims)
            {
                if (prim.Name.CompareTo("Tx") == 0)
                {
                    m_log.DebugFormat("[BARE BONES NON SHARED] Found the transmitter!");
                    transmitter = (SceneObjectGroup)prim;
                }
                if (prim.Name.CompareTo("Ry") == 0)
                {
                    m_log.DebugFormat("[BARE BONES NON SHARED] Found the Receiver!");
                    receiver = (SceneObjectGroup)prim;
                   
                }//if
            }//foreach
		}
			catch(Exception ex)
			{
				
			}
            return transmitter != null && receiver != null;
        }
        /// <summary>
        /// For every ray generated by the transmitter, trace it and check if it will be received by the transmitter 
        /// or not.
        /// </summary>
        public void startRayTracerBrutefoce()
        {
            m_log.DebugFormat("[BARE BONES NON SHARED] Started Raytracing!");

            float lat, lon;

            //For every lon and lat increase by ANGLE_BETWEEN_RAY
            for (lon = 0; lon < 360; lon += ANGLE_BETWEEN_RAY)
            {
                //m_log.DebugFormat ("[BARE BONES NON SHARED] Raytracing longtitude {0}!", lon);
                m_log.DebugFormat("[Ray Tracer] Raytracing {0}/360", lon);

                for (lat = 0; lat < 360; lat += ANGLE_BETWEEN_RAY)
                {
                    double lonr = lon * DEG_TO_RAD;
                    double latr = lat * DEG_TO_RAD;
                    
                    //Note: Lat = angle of elevation. Lon = angle around the z-axis
                    //To get a point on a sphere using 2 angle 
                    //Assuming Radius = 1 so we can get rid of multiplying radius. 
                    //http://stackoverflow.com/questions/969798/plotting-a-point-on-the-edge-of-a-sphere

                    float x = (float)(Math.Sin(latr) * Math.Cos(lonr));
                    float y = (float)(Math.Sin(latr) * Math.Sin(lonr));
                    float z = (float)(Math.Cos(latr));

                    Vector3 pointOnSphere = new Vector3(x, y, z);
                    pointOnSphere.Normalize();

                    Vector3 direction = pointOnSphere;
                    Ray ray = new Ray(transmitter.RootPart.AbsolutePosition, direction);

                    //Trace this ray
                    string pathID = getPathID();
                    PathFromTxToRy thisRayPath = new PathFromTxToRy(this, transmitter.RootPart.AbsolutePosition, pathID);
                    thisRayPath = traceRay(thisRayPath, ray, transmitter.RootPart);

                    //If it reaches the receiver, then add it to the hit list. 
                    if (thisRayPath.reachesReceiver && !checkPathIsDrawn(thisRayPath))
                    {
                        pathHits[thisRayPath.getNoOfReflection()].Add(pathID, thisRayPath);
                        noCount++;
                    }
                }
           }//for
        }
        public void DirectMap0Ref()
        {
            string pathID = getPathID();
            PathFromTxToRy path = new PathFromTxToRy(this, transmitter.RootPart.AbsolutePosition, pathID);
            //Direction from transmitter to the reciever 
            Vector3 direction = receiver.RootPart.AbsolutePosition - transmitter.RootPart.AbsolutePosition;
            //Ray vector from transmitter to the receiver
            Ray ray = new Ray(transmitter.RootPart.AbsolutePosition, direction);
            //Get the first object the ray hit
            EntityIntersectionWithPart intersection = findNextHit(ray, transmitter.RootPart);
            if (intersection.intersection.HitTF && intersection.intersectPart.Equals(receiver.RootPart))
            {
                path.addNextPoint(receiver.RootPart.AbsolutePosition, receiver.RootPart.Material);
                path.reachesReceiver = true;
                pathHits[0].Add(pathID, path);
            }//if
        }
        public void DirectMap1Ref()
        {
            worldObjects.ForEach(delegate(SceneObjectPart part)
            {
                ReflectionPoint reflectedPoint = findReflectionPoint
                    (transmitter.RootPart.AbsolutePosition, receiver.RootPart.AbsolutePosition, part);
                if (reflectedPoint.found)
                {
                    string pathID = getPathID();
                    PathFromTxToRy newPath = new PathFromTxToRy(this, transmitter.RootPart.AbsolutePosition, pathID);
                    newPath.addNextPoint(reflectedPoint.reflectionPoint, reflectedPoint.surfaceMaterial);
                    newPath.addNextPoint(receiver.RootPart.AbsolutePosition, receiver.RootPart.Material);
                    newPath.reachesReceiver = true;
                    pathHits[1].Add(pathID, newPath);
                }//if
            });//forEachPart
        }
        /// <summary>
        /// A recursive method which trace a ray until its power is less than ray-minimum power thershold
        /// </summary>
        /// <param name="path">New PathFromTxToRy object.</param>
        /// <param name="ray">A starting ray (first ray)</param>
        /// <param name="lastIntersectPart">A world object which this ray last intersect, or start</param>
        /// <returns>PathFromTxToRy with True if it reaches receiver and False if it did not reach the receiver.</returns>
        public PathFromTxToRy traceRay(PathFromTxToRy path, Ray ray, SceneObjectPart lastIntersectPart)
        {
            EntityIntersectionWithPart nextHit = findNextHit(ray, transmitter.RootPart);

            if (nextHit.intersection.HitTF)
            {
                //Check for limit number of reflection allowed.
                if(path.getNoOfReflection() >= MAX_REFLECTIONS)
                {
                    path.reachesReceiver = false;
                    return path;
                }
                //drawRay(ray.Origin, nextHit.intersection.ipoint);
                else if (nextHit.intersectPart.Equals(receiver.RootPart)) //If it reaches the receiver
                {
                    path.reachesReceiver = true;
                    path.addNextPoint(nextHit.intersection.ipoint, receiver.RootPart.Material);
                    return path;
                }//if

                //recursive case, keep tracing this ray.
                else
                {
                    path.addNextPoint(nextHit.intersection.ipoint, nextHit.intersectPart.Material);
                    Vector3 reflectedVector = getReflectedVector(ray.Direction, nextHit.intersection.normal);
                    Ray newRay = new Ray(nextHit.intersection.ipoint, reflectedVector);
                    return traceRay(path, newRay, nextHit.intersectPart);
                }//else if
            }
            else //It didn't hit anything
            {
                path.reachesReceiver = false;
                return path;
            }//else
        }
        /// <summary>
        /// A method which find the first object the ray hit. This is done by comparing distances. 
        /// The smallest distance is the distance between the intersection point and the ray start point. 
        /// </summary>
        /// <param name="ray">The ray which will be used to test the intersection against each part in the scene</param>
        /// <param name="source">An object which the ray start from. We need this to make sure that the shortest
        /// distance isn't zero (from itself to itself)</param>
        /// <returns>Intersection point with True if this ray intersect something, or false if nothing at all</returns>
        public EntityIntersectionWithPart findNextHit(Ray ray, SceneObjectPart source)
        {
            float smallestDistance = 1000000f;
            EntityIntersection closestIntersection = new EntityIntersection();
            SceneObjectPart closestPart = new SceneObjectPart();
            foreach (SceneObjectPart part in worldObjects)
            {
                if (!part.Equals(source)) //Cannot intersect itself
                {
                    //Test if the ray intersect this part. 
                    EntityIntersection intersection;
                    if (part.GetPrimType() == OpenSim.Region.Framework.Scenes.PrimType.SPHERE)
                    {
                        intersection = part.TestIntersection(ray, part.ParentGroup.GroupRotation);
                    }
                    else
                    {
                        intersection = part.TestIntersectionOBB(ray, part.ParentGroup.GroupRotation, true, false);
                    }
                    
                    //If yes then check if the distance is smaller. 
                    if (intersection.HitTF && checkPointIntersectPrim(intersection.ipoint, part, 0.1f))
                    {
                        //If yes, then remember this distance and this intersection as the current 'return' candidate
                        if (intersection.distance < smallestDistance)
                        {
                            smallestDistance = intersection.distance;
                            closestIntersection = intersection;
                            closestPart = part;
                        }//if
                    }//if
                }//if
            }//foreach
            return new EntityIntersectionWithPart(closestIntersection, closestPart);
        }
        /// <summary>
        /// Find a point on a prim which is the reflection point of 2 points (pointFrom and pointTo). 
        /// This method uses the concept of "angle of incident = angle of rreflection" then solve
        /// that equation. 
        /// </summary>
        /// <param name="pointFrom">Source</param>
        /// <param name="pointTo">Target</param>
        /// <param name="part">a prim which is used as a reflection surface</param>
        /// <returns></returns>
        public ReflectionPoint findReflectionPoint(Vector3 pointFrom, Vector3 pointTo, SceneObjectPart part)
        {
            float x = 0, y = 0, z = 0;
            bool xIsZero = true, yIsZero = true, zIsZero = true;

            //Get a vector from start to the prim absolute position. Use that vector to test intersection
            //and get the normal of the prim. 

            Vector3 direction = part.AbsolutePosition - pointFrom;
            EntityIntersection intersection = part.TestIntersectionOBB(new Ray(pointFrom, direction), part.ParentGroup.GroupRotation, true, false);

            //Return false if the ray hits nothing.
            if (!intersection.HitTF)
                return new ReflectionPoint();

            if (intersection.normal.X != 0) { xIsZero = false; }
            if (intersection.normal.Y != 0) { yIsZero = false; }
            if (intersection.normal.Z != 0) { zIsZero = false; }


            //Note: We can get rid of the first three if(else) statement below. But for computation result, 
            //it is better to use them as the 'last else' statement is quite computationally intensive. 

            if (!xIsZero && yIsZero && zIsZero) //{1, 0, 0}
            {
                x = intersection.ipoint.X;
                y = solvePointEquation(pointFrom.Y, pointTo.Y, x, pointFrom.X, pointTo.X);
                z = solvePointEquation(pointFrom.Z, pointTo.Z, x, pointFrom.X, pointTo.X);
            }
            else if (xIsZero && !yIsZero && zIsZero) //{0, 1, 0}
            {
                y = intersection.ipoint.Y;
                x = solvePointEquation(pointFrom.X, pointTo.X, y, pointFrom.Y, pointTo.Y);
                z = solvePointEquation(pointFrom.Z, pointTo.Z, y, pointFrom.Y, pointTo.Y);
            }
            else if (xIsZero && yIsZero && !zIsZero) //{0, 0, 1}
            {
                z = intersection.ipoint.Z;
                x = solvePointEquation(pointFrom.X, pointTo.X, z, pointFrom.Z, pointTo.Z);
                y = solvePointEquation(pointFrom.Y, pointTo.Y, z, pointFrom.Z, pointTo.Z);
            }

            else if (xIsZero && yIsZero && zIsZero)
            {
                throw new Exception("There is no such normal vector which has x, y, and z = 0");
            }

            //else create a virtual enviroment where the reflection plane has a normal to be x-axis.
            //Find the reflection point on that virtual plane, then rotate it back to map the prim surface.

            else
            {
                //Initialise all the required rotation variables

                Quaternion partRotation = Vector3.RotationBetween(intersection.normal, new Vector3(1, 0, 0));
                Quaternion inverseRotation = Quaternion.Inverse(partRotation);
                Matrix4 partRotationM = Matrix4.CreateFromQuaternion(partRotation);
                Matrix4 inverseRotationM = Matrix4.CreateFromQuaternion(inverseRotation);

                //Direction vectors from prim absolute position to pointFrom, pointTo, and the intersection point.

                Vector3 newPointFrom = pointFrom - part.AbsolutePosition;
                Vector3 newPointTo = pointTo - part.AbsolutePosition;
                Vector3 newIntersection = intersection.ipoint - part.AbsolutePosition;

                //Rotate those directions vectors so that they map on a plane where normal = x-axis

                newPointFrom = Vector3.Transform(newPointFrom, partRotationM);
                newPointTo = Vector3.Transform(newPointTo, partRotationM);
                newIntersection = Vector3.Transform(newIntersection, partRotationM);

                //Convert those directions vectors back into a point

                newPointFrom += part.AbsolutePosition;
                newPointTo += part.AbsolutePosition;
                newIntersection += part.AbsolutePosition;

                //Now we calculate the relfection point by solving the equation.

                x = newIntersection.X;
                y = solvePointEquation(newPointFrom.Y, newPointTo.Y, x, newPointFrom.X, newPointTo.X);
                z = solvePointEquation(newPointFrom.Z, newPointTo.Z, x, newPointFrom.X, newPointTo.X);

                //Rotate the reflection point back to map the original prim surface.

                Vector3 virtualReflectionPoint = new Vector3(x, y, z) - part.AbsolutePosition;
                virtualReflectionPoint = Vector3.Transform(virtualReflectionPoint, inverseRotationM);
                virtualReflectionPoint += part.AbsolutePosition;

                //Set result x, y and z.

                x = virtualReflectionPoint.X;
                y = virtualReflectionPoint.Y;
                z = virtualReflectionPoint.Z;
            }

            //Check if the found reflection point (x, y, and z) is actually on the prim surface. 
            //If yes then return that point and true. If not then return point(0, 0, 0) and false;

            ReflectionPoint reflectionPoint = new ReflectionPoint(new Vector3(x, y, z), true);
            if (checkPointIntersectPrim(reflectionPoint.reflectionPoint, part, 0.05f))
            {
                reflectionPoint.surfaceMaterial = part.Material;
                return reflectionPoint;
            }
            else { return new ReflectionPoint(); }
        }
        /// <summary>
        /// A very specific method used to assist findReflectionPoint(). It is used to solve an equation
        /// of when given a plane found, find another point. 
        /// Please use TROVE document as this might be very confusing
        /// </summary>
        public float solvePointEquation(float Tx, float Rx, float y, float Ty, float Ry)
        {
            // Here is the format
            //
            //       x - Tx             Rx - x
            //       ------     =       ------
            //       y - Ty             y - Ry
            //
            // where x is unknown. 

            float leftDenominator = y - Ty;
            float rightDenominator = y - Ry;

            //re-arrange equation and compute x
            return (((rightDenominator * Tx) + (leftDenominator * Rx)) / (rightDenominator + leftDenominator));

        }
        /// <summary>
        /// Apply Snells law to calculate the angle of refraction. 
        /// </summary>
        /// <param name="incidentAngle">Angle of incident in radian</param>
        /// <param name="refIndex1">Refractive index of medium 1</param>
        /// <param name="refIndex2">Refractive index of medium 2</param>
        /// <returns>angle of refrection or reflection in radian</returns>
        /// <author> Mona </author>
        double getRefAngle(double incidentAngle, double refIndex1, double refIndex2)
        {
            //          sin(θ1)         v1           n2
            //          -----      =   ----    =    ----
            //          sin(θ2)         v2           n1

            // where θ1 = incident angle, θ2 = refracted angle, v = velocity of light going 
            //through a certain medium n = refrected index of a certain medium.

            double refractedAngle = 0;
            refractedAngle = Math.Asin((refIndex1 * incidentAngle) / refIndex2);
            return refractedAngle;
        }
        /// <summary>
        /// Get a reflected vector which has angle of incident = angle or reflection.
        /// </summary>
        /// <param name="direction">Given a direction vector</param>
        /// <param name="normal">The normal of the </param>
        /// <returns></returns>
        public  Vector3 getReflectedVector(Vector3 direction, Vector3 normal)
        {
            Quaternion rotation = Vector3.RotationBetween(direction, normal);
            return Vector3.Negate(Vector3.Transform(normal, Matrix4.CreateFromQuaternion(rotation)));
        }
        /// <summary>
        /// Check if a given point is within the rectangle boundary of a prim. 
        /// Note: This method works best with retangle object. 
        /// </summary>
        /// <param name="point">A point to be checked</param>
        /// <param name="prim">An object in the world</param>
        /// <param name="precision">Wrapper size around the object/prim in metre. If you don't understand then just use 0.05f</param>
        /// <returns></returns>
        public bool checkPointIntersectPrim(Vector3 point, SceneObjectPart prim, float precision)
        {
            //Offset is used to determined boundary. Boundary = mid-point +- offset.
            //Precision = 0 means the point is absolutely within the boundary. 
            //Increase in precision = allowing more error for 
            //the point to intersect the prim further. i.e. don't make it too big 
            //but I would not recommend 0 incase some rounding error 

            Vector3 offset = (prim.Scale / 2) + new Vector3(precision, precision, precision);
            Vector3 primPosition = prim.AbsolutePosition;
            Vector3 maxBoundary = primPosition + offset;
            Vector3 minBoundary = primPosition - offset;

            //At the moment, if the prim has been rotated, the point of intersection will not hit the boundary,
            //so we need to rotate the point to map it to the original prim where no rotation has been done
            //Do this by create a vector from the prim position to the intersection point, rotate that vector, then 
            //recalculate the intersection point. 

            Quaternion rotation = prim.RotationOffset * -1;
            Vector3 rotationVector = point - primPosition;
            rotationVector = Vector3.Transform(rotationVector, Matrix4.CreateFromQuaternion(rotation));
            rotationVector += primPosition;

            //Check if the intersection is within the boundary.

            if ((rotationVector.X >= minBoundary.X && rotationVector.X <= maxBoundary.X) &&
                (rotationVector.Y >= minBoundary.Y && rotationVector.Y <= maxBoundary.Y) &&
                (rotationVector.Z >= minBoundary.Z && rotationVector.Z <= maxBoundary.Z))
            {
                return true;
            }//if
            else
                return false;
        }
        public double getStrengthAt(string name, string _position)
        {
            //Given name should be in the format of "ray_noOfReflection_pathID_rayID"

            string[] tokens = name.Split('_');
            int noOfReflection = int.Parse(tokens[1]);
            string pathID = tokens[2];
            string rayID = tokens[3];

            tokens = _position.Split('_');
            float x = float.Parse(tokens[0]);
            float y = float.Parse(tokens[1]);
            float z = float.Parse(tokens[2]);
            Vector3 position = new Vector3(x, y, z);

            PathFromTxToRy path = pathHits[noOfReflection][pathID];
            RayAsPathSection ray = path.rayList[rayID];
            return ray.getStrengthAt(position);
            
        }
        /// <summary>
        /// Get the current rayID then increase it so that every ray id is unique
        /// </summary>
        public string getRayID()
        {
            string id = rayID.ToString();
            rayID++;
            return id;
        }
        /// <summary>
        /// Get the current pathID then increase it so that every path id is unique
        /// </summary>
        /// <returns></returns>
        public string getPathID()
        {
            string id = pathID.ToString();
            pathID++;
            return id;
        }
        /// <summary>
        /// Draw a given path (A given path may contains many rays). This method just get all the ray in the 
        /// given path and draw them sequentially.
        /// </summary>
        /// <param name="path"></param>
        public void drawRayPath(PathFromTxToRy path)
        {
            foreach(KeyValuePair<string, RayAsPathSection> ray in path.rayList)
            {
                //Note: Team KeyValuePair and Value are c# syntax for accessing dictionary element value and its key.
                // To get the key, we do section.Key. To get the value we do section.Value;

                string name = "ray_" + path.getNoOfReflection() + "_" + path.id + "_" + ray.Value.id;
                drawRay(ray.Value.startPoint, ray.Value.endPoint, name);
            }
        }
        /// <summary>
        /// Draw a ray (which has a shape of rectangle but with thin y and z value) from 2 given points. 
        /// The ray is drawn on the mid point between the 2 given points then rotate around y-axis and z-axis
        /// to make the ray connect between 2 points. For more information, please have a look at online TROVE Developer Documentations.
        /// By Thanakorn Tuanwachat 07/2013
        /// </summary>
        /// <param name="startPoint">The point where the ray start</param>
        /// <param name="endPoint">The point where the ray end</param>
        public void drawRay(Vector3 startPoint, Vector3 endPoint, string name)
        {
            //Set up parameters for drawing an object in the world. Width = 0.2 unit and depth = 0.01 unit.
            //Length of the ray is the distance from the two given points

            float rayWidth = 0.05f; 
            float rayDepth = 0.05f;

            //Distance and Mid-point between 2 points. vectorFromStartToEnd can be used to represent a distance 
            //from x.end to x.start, y.end to y.start, z.end to z.start

            double rayLength = (startPoint - endPoint).Length();
            Vector3 midPoint = (startPoint + endPoint) / 2;
            Vector3 vectorFromStartToEnd = endPoint - startPoint;
            Vector3 xAxis = new Vector3(1, 0, 0);

            //Angles for rotating the objects (dervied from x, y, and z distances)
            //See developer documentations for more details

            Quaternion rotation = Vector3.RotationBetween(xAxis, vectorFromStartToEnd);

            //Start drawing the ray

            Vector3 dimension = new Vector3((float)rayLength, (float)rayWidth, (float)rayDepth);
            addObjectToTheWorld(name, midPoint, dimension, rotation, PrimType.Cylinder, rayScript);
           

        }
        /// <summary>
        /// Delete all the object in the world whose name = Ray
        /// </summary>
        public void deleteRays()
        {
            try
            {
                EntityBase[] R_prims = m_scene.GetEntities();
                m_log.DebugFormat("[BARE BONES NON SHARED] Found {0} Entities!", R_prims.Length);

                //For each prim in the world, if their name is Rays, then delete them. 
                foreach (EntityBase prim in R_prims)
                {
                    if (prim.Name.CompareTo("Rays") == 0)
                    {
                        m_scene.DeleteSceneObject((SceneObjectGroup)prim, false);
                    }

                }
                m_log.DebugFormat("[BARE BONES NON SHARED] Delete all Rays in scene");
            }
            catch (Exception ex)
            {
            }

        }
        /// <summary>
        /// Add a given object to the world. If you prefer argument to use default value, when pass it as null. 
        /// *There is 1 compulsory fields which is position of the object. The rest are optionals. 
        /// By Thanakorn Tuanwachat 07/2013
        /// </summary>
        /// <param name="name">Name of this object. Use default value "primative" if null is given</param>
        /// <param name="position">"Vector(x y z) where x, y, and z represent the coordinates in the world"</param>
        /// <param name="dimension">"Vector(x, y, z) where x, y, and z represent the size of the object"</param>
        /// <param name="rotation">double(x, y, z) where x, y, and z represent angle of rotation from its axis in radian</param>
        /// <param name="primType">There are only 3 types which are Box, </param>
        /// <param name="script"> The LSL script which will be attached to this object</param>
        public void addObjectToTheWorld(string name, Vector3 position, Vector3 dimension, 
                                        Quaternion rotation, int primType, string script)
        {
            //When coloring object, -1 indicate that set all faces that color. 
            int face = -1;

            //Generate a new UUID for this ray
            UUID rayUUID = UUID.Random();

            //Place an object into the world. It can either be Box, Sphere, or Cylinder. according to the given PrimType

            SceneObjectGroup sog;
            switch (primType)
            {
                case PrimType.Box:
                    sog = new SceneObjectGroup(new UUID(rayUUID), position, OpenSim.Framework.PrimitiveBaseShape.CreateBox());
                    break;
                case PrimType.Sphere:
                    sog = new SceneObjectGroup(new UUID(rayUUID), position, OpenSim.Framework.PrimitiveBaseShape.CreateSphere());
                    break;
                case PrimType.Cylinder:
                    sog = new SceneObjectGroup(new UUID(rayUUID), position, OpenSim.Framework.PrimitiveBaseShape.CreateCylinder());
                    break;
                default:
                    sog = new SceneObjectGroup(new UUID(rayUUID), position, OpenSim.Framework.PrimitiveBaseShape.CreateBox());
                    break;
            }//switch

            //Check if it is possible to set thses parameters. If not then use default value

            if(dimension != null)
            {
              sog.RootPart.Scale = dimension;
            }
            if(rotation != null)
            {
                sog.RootPart.UpdateRotation(rotation);
            }//if
            if(name != null)
            {
                sog.Name = name;
            }//if
            else
            {
                sog.Name = "Primative";
            }//else
            if (script != null)
            {
                addScript(sog.RootPart, script);
            }

            //Add this object to the scene.

            m_scene.AddNewSceneObject(sog, false);
            sog.ScheduleGroupForFullUpdate();
            sog.HasGroupChanged = true;
        }
        /// <summary>
        /// </summary>
        /// <author>Mona</author>>
        /// <param name="part"></param>
        public void addScript(SceneObjectPart part, string script)
        {
            AssetBase asset = new AssetBase();
            asset.Name = "Default touch script";
            asset.Description = "Default touch script";
            asset.Type = 10; // 10 is the asset type for scripts.
            asset.FullID = UUID.Random();
            asset.Data = Encoding.ASCII.GetBytes(script);
            m_scene.AssetService.Store(asset);

            TaskInventoryItem taskItem = new TaskInventoryItem();

            taskItem.ResetIDs(part.UUID);
            taskItem.ParentID = part.UUID;
            taskItem.CreationDate = (uint)(DateTime.UtcNow - new DateTime(1970, 1, 1)).TotalSeconds;
            taskItem.Name = "Default touch script";
            taskItem.Description = "Default touch script";
            taskItem.Type = 10;
            taskItem.InvType = 10;
            taskItem.OwnerID = UUID.Zero;
            taskItem.CreatorID = UUID.Zero;
            taskItem.BasePermissions = 2147483647; //0; // Not sure, let's try zeros.
            taskItem.CurrentPermissions = 2147483647; //0;
            taskItem.EveryonePermissions = 0;
            taskItem.GroupPermissions = 0;
            taskItem.NextPermissions = 532480; //0;
            taskItem.GroupID = UUID.Zero;
            taskItem.Flags = 0;
            taskItem.PermsGranter = UUID.Zero;
            taskItem.PermsMask = 0;
            taskItem.AssetID = asset.FullID;
            part.ParentGroup.ScheduleGroupForTerseUpdate();
            part.Inventory.AddInventoryItem(taskItem, false);
            m_scene.AddNewSceneObject(part.ParentGroup, false);
            part.Inventory.CreateScriptInstance(taskItem, 0, false, m_scene.DefaultScriptEngine, 0);
        }
        /// <summary>
        /// There seems to be a bug that causes each path to be drawn twice. This function check, if the
        /// given path has already been drawn. This function should be called everytime before adding a path
        /// to a hit list. 
        /// </summary>
        /// <param name="path"></param>
        /// <returns>True = the path has already been drawn. False = the path hasn't been drawn</returns>
        bool checkPathIsDrawn(PathFromTxToRy path)
        {
            Vector3 midPoint = new Vector3();
            //To reduce the computation time, we only one ray from a path. i.e. break the loop when getting the first one. 
            foreach (KeyValuePair<string, RayAsPathSection> ray in path.rayList)
            {
                midPoint = ray.Value.endPoint - ray.Value.startPoint;
                midPoint.X = Math.Abs(midPoint.X);
                midPoint.Y = Math.Abs(midPoint.Y);
                midPoint.Z = Math.Abs(midPoint.Z);
                break;
            }//foreach

            //This loop will determine whether or not this path has been drawn before. It does this by 
            //compare the 'midPoint' against the list of points. 
            foreach (Vector3 pos in allRayPos)
            {
                if (pos.CompareTo(midPoint) == 0)
                {
                    return true;
                }//if
            }//foreach

            //Meaning that this path hasn't been drawm before. Add all of its ray's midpoint to the list
            foreach (KeyValuePair<string, RayAsPathSection> ray in path.rayList)
            {
                Vector3 newRayPos = new Vector3();
                newRayPos = ray.Value.endPoint - ray.Value.startPoint;
                newRayPos.X = Math.Abs(newRayPos.X);
                newRayPos.Y = Math.Abs(newRayPos.Y);
                newRayPos.Z = Math.Abs(newRayPos.Z);
                allRayPos.Add(newRayPos);
            }//foreach
            return false;
        }
        /// <summary>
        /// A point on a prim which is the reflection point of another 2 points. 
        /// It also contains variable 'found' which indicates whether if this reflection point
        /// exists. (it found = false, then don't use it)
        /// </summary>
        public class ReflectionPoint
        {
            public Vector3 reflectionPoint;
            public bool found;
            public int surfaceMaterial;

            public ReflectionPoint()
            {
                found = false;
            }
            public ReflectionPoint(Vector3 _reflectionPoint, bool _found)
            {
                reflectionPoint = _reflectionPoint;
                found = _found;
            }
        }
        /// <summary>
        /// Similar to EntityIntersection but also contains a reference/pointer to the part the intersection happen
        /// </summary>
        public class EntityIntersectionWithPart
        {
            public EntityIntersection intersection;
            public SceneObjectPart intersectPart;
            public EntityIntersectionWithPart(EntityIntersection _intersection, SceneObjectPart part)
            {
                intersection = _intersection;
                intersectPart = part;
            }//constructor
        }
        public class RayAsPathSection
        {
            public Vector3 startPoint;
            public Vector3 endPoint;
            public double maxPower;
            public double minPower;
            public string id;
            RayTracer rayTracerModel;

            public RayAsPathSection(Vector3 _startPoint, Vector3 _endPoint, double startPower, string _id, RayTracer _rayTracerModel)
            {
                rayTracerModel = _rayTracerModel;
                startPoint = _startPoint;
                endPoint = _endPoint;
                maxPower = startPower;
                minPower = maxPower - RadioPower.CalculatePathloss(Vector3.Distance(startPoint, endPoint), rayTracerModel.runningFreqRT, rayTracerModel.runningFreqRTUnit);
                id = _id;
            }//constructor

            /// <summary>
            /// Get a power in dBW at a given point. Calculate the distance from the start point to
            /// the given point then use that distance to calculate the new power. 
            /// </summary>
            /// <param name="touchedPoint"></param>
            /// <returns></returns>
            public double getStrengthAt(Vector3 touchedPoint)
            {
                double distance = Vector3.Distance(startPoint, touchedPoint);
                double pathLoss = RadioPower.CalculatePathloss(distance, rayTracerModel.runningFreqRT, rayTracerModel.runningFreqRTUnit);
                m_log.DebugFormat("[Distance: ]" + distance);
                m_log.DebugFormat("[StartingPower ]" + maxPower);
                m_log.DebugFormat("[PathLoss]" + pathLoss);
                return maxPower - pathLoss;
            }//getStrengthAt
            /// <summary>
            /// Calculate and return the left-over power after the reflection at the 
            /// end point of this ray.
            /// </summary>
            /// <param name="primMaterial">The material which reflecting this ray</param>
            /// <returns>Left over power in dBW</returns>
            public double getRefLoss(Vector3 nextPoint, int primMaterial)
            {
                //To find the angle between 2 vectors
                //
                //    A.B
                //  ------  = cos(θ)
                //  |A||B|

                Vector3 ray1 = startPoint - endPoint;
                Vector3 ray2 = nextPoint - endPoint;
                double airRefractiveIndex = RefrectiveIndex.AIR;
                double surfaceRefractiveIndex = RefrectiveIndex.getRefractiveIndex(primMaterial);

                //Calculate angle or incident, and reflection/refraction angle. 
                RayTracer rayTracerModel = new RayTracer();
                double incidentAngle = Math.Acos(Vector3.Dot(ray1, ray2) / (ray1.Length() * ray2.Length()));
                double reflectionAngle = rayTracerModel.getRefAngle(incidentAngle, airRefractiveIndex, surfaceRefractiveIndex);

                //Calculate and return reflection/refraction loss
                double refLoss =  (minPower - RadioPower.ComputeRefloss(airRefractiveIndex, surfaceRefractiveIndex, incidentAngle, reflectionAngle));
                return refLoss;
            }
        }
        /// <summary>
        /// A path from Tx to Rx. A path can consist of 1 or more than 1 ray. Ray = a line from one point to another.
        /// </summary>
        public class PathFromTxToRy
        {
            //rays = a list of rays from Tx to Rx. PathFromTxToRy may have more than one ray due to reflection. 

            public Dictionary<string, RayAsPathSection> rayList; 
            public Vector3 transmitterPos;                      //Transmitter position
            public bool reachesReceiver;                        //Has this path reached the reveicer?
            RayTracer rayTracerModel;                           //Ray tracer model. (The method used to create this object)
            RayAsPathSection lastRay = null;                    //The current end/last ray of this path
            public string id;

            public PathFromTxToRy(RayTracer parent, Vector3 _start, string _id)
            {
                rayTracerModel = parent;
                transmitterPos = _start;
                reachesReceiver = false;
                rayList = new Dictionary<string, RayAsPathSection>();
                id = _id;
            }
            /// <summary>
            /// Add a new reflection point or receiver point(destination) to this path
            /// </summary>
            /// <param name="nextPoint">the reflection point or receiver</param>
            /// <param name="primMaterial">Material number from 0-6 NOT refractive index.</param>
            public void addNextPoint(Vector3 nextPoint, int primMaterial)
            {
                //If there is a last ray then uses its endPoint as a start point for this new ray
                string rayID = rayTracerModel.getRayID();
                if (lastRay != null)
                {
                    //double newStartPower = lastRay.getRefLoss(nextPoint, primMaterial);
                    double newStartPower = lastRay.minPower;
                    RayAsPathSection ray = new RayAsPathSection(lastRay.endPoint, nextPoint, newStartPower, rayID, rayTracerModel);
                    rayList.Add(rayID, ray);
                    lastRay = ray;
                }
                else //This is the first ray starting from the transmitter to the given 'nextPoint'
                {
                    RayAsPathSection firstRay = new RayAsPathSection(transmitterPos, nextPoint, rayTracerModel.runningPowerRT, rayID, rayTracerModel);
                    rayList.Add(rayID, firstRay);
                    lastRay = firstRay;
                }
            }
            /// <summary>
            /// Get the number of reflection. Number of reflection = total number of rays -1.
            /// </summary>
            /// <returns></returns>
            public int getNoOfReflection()
            {
                return rayList.Count() - 1;
            }
        }//PathFromTxToRy object.

    }//RayTracer

}//namespace
