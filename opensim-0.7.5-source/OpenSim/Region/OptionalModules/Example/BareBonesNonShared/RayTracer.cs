using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using log4net;
using OpenSim.Region.Framework.Scenes;
using OpenSim.Region.Framework.Interfaces;
using System.Reflection;
using OpenMetaverse;
using System.Threading;
using Nini.Config;
using OpenSim.Framework;
using OpenMetaverse.Assets;
using OpenSim.Region.OptionalModules.Example.BareBonesNonShared;
using System.Drawing;

/// Author: Mihail Kovachev
/// Author: Mona Demaidi
/// Author: Thanakorn Tuanwachat
namespace OpenSim.Region.OptionalModules.Example.BareBonesNonShared
{
    /// <summary>
    /// Added By Mona
    /// Determine the refractive index of different PrimMaterials
    /// </summary>
    public static class RefrectiveIndex
    {
        public const double STONE = 5;
        public const double METAL = 14;
        public const double GLASS = 1.4;
        public const double WOOD = 4;
        public const double FLESH = 1.3;
        public const double PLASTIC = 1.5;
        public const double RUBBER = 1.5;
        public const double AIR = 1;

        public static double getRefractiveIndex(int material)
        {
            switch (material)
            {
                case 0:
                    return STONE;
                case 1:
                    return METAL;
                case 2:
                    return GLASS;
                case 3:
                    return WOOD;
                case 4:
                    return FLESH;
                case 5:
                    return PLASTIC;
                case 6:
                    return RUBBER;
                case 7:
                    return AIR;
                default:
                    return AIR;
            }
        }
        
    }
    /// <summary>
    /// Shape of an object in the world. (Class is used when drawing an object)
    /// </summary>
    static class PrimType
    {
        public const int Box = 1;
        public const int Sphere = 2;
        public const int Cylinder = 3;
    }
    public class RayTracer
    {
        //m_log: used for outputting message on standard output. 
        //m_prims of objects/entities in the world.
        //hits: Array of List reflections from 0 to MAX_REFLECTIONS. 
        private static readonly ILog m_log = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

        Scene m_scene=null;                 //scene in the world which contains all the objects in the world 
        EntityBase[] m_prims;               //array of entity. (This will be used to stored all the entity in the world)
        IScriptModuleComms m_commsMod;      //Can be used to send message back to the script
        List<SceneObjectPart> worldObjects; //All objects in the world which its distance to the transmitter < MAX_DISTANCE
        SceneObjectGroup transmitter;       //Transmitter in the world
        SceneObjectGroup receiver;          //receiver in the world
        List<PathFromTxToRy>[] hits;        //Array of paths from Transmitter to the receiver.

        //Default Ray tracer variables. These variables will be reset then the "restart ray stacer" button is pressed

        int MAX_REFLECTIONS = 5;            //Total number of reflection can occur
        float MAX_DISTANCE = 30;            //The longest length of a single ray (without reflection)
        int ANGLE_BETWEEN_RAY = 1;          //Angle between any ray (used in BlindSearch/BruteForce method)
        string runningFreqRT = "2.4";       //Frequency of the radio
        string runningFreqRTUnit = "ghz";   //Unit of the frequency
        double runningPowerRT = 44;         //Power generated by the transmitter
        string runningPowerRTUnit = "dBW";  //Unit of the power generated by the transmitter
        string RTModel;                     //Receiver model
        string ANModel;                     //Antenna model. e.g. isotropic, directional etc.
        UUID scriptID;                      //UUID of the script which called this class.
        int MAX_PATH = 5;                   //Total number of path available for viewing, for each reflection.

        double DEG_TO_RAD = Math.PI / 180.0;

        /// <summary>
        /// Initialise all variables needed to be used by this ray tracer model. 
        /// </summary>
        /// <param name="scene">The scene in the world</param>
        /// <param name="setOfvariables">Set of variable values from the remote control</param>
        /// <param name="_scriptID">UUID of the script which called this function</param>
        public void Initialise(Scene scene, string setOfvariables, UUID _scriptID)
        {
            m_scene = scene;
            m_commsMod = m_scene.RequestModuleInterface<IScriptModuleComms>();
            scriptID = _scriptID;

            //Initialise variables parsed from the remote control. 
            int noOfInitVar = initialiseVariables(setOfvariables);
            m_log.DebugFormat("[RAY TRACER INITIALISATION]: total number of initialised variables = " + noOfInitVar.ToString());
            
            //max_reflection + 1 as it starts from 0 reflection (line of sight)
            //Array of list of paths. e.g. hits[1] = list of paths for one reflections. 

            hits = new List<PathFromTxToRy>[MAX_REFLECTIONS + 1];
            m_log.DebugFormat("[RAY TRACER INITIALISATION]: Complete!");

        }
        /// <summary>
        /// set RayTracer class varaibles according to the given set of variables. 
        /// This set of variables come from the in-world script from the remote control, when "restart raytracer" button 
        /// is pressed. 
        /// </summary>
        /// <param name="setOfVariables"></param>
        public int initialiseVariables(string setOfVariables)
        {
            //Each element will have a format of e.g. Frequency=10, FrequencyUnit=MHz etc.
            string[] arrayOfVariables = setOfVariables.Split('_');
            
            //Check if all the variable has been initialise by counting. 
            int countVariable = 0;
            //Foreach of those element the the variables
            foreach (string variableNameAndValue in arrayOfVariables)
            {
                string[] variableNameAndValueToken = variableNameAndValue.Split('=');
                //if variable has value attatch to it.
                if (variableNameAndValueToken.Length == 2)
                {
                    string variableName = variableNameAndValueToken[0];
                    string variableValue = variableNameAndValueToken[1];
                    switch (variableName)
                    {

                        case "Frequency":
                            runningFreqRT = variableValue;
                            countVariable++;
                            break;

                        case "FrequencyUnit":
                            runningFreqRTUnit = variableValue;
                            countVariable++;
                            break;

                        case "TransmitterPower":
                            runningPowerRT = Convert.ToDouble(variableValue);
                            countVariable++;
                            break;
                        case "TransmitterPowerUnit":
                            runningPowerRTUnit = variableValue;
                            countVariable++;
                            break;
                        case "Model":
                            RTModel = variableValue;
                            countVariable++;
                            break;
                        case "AngleBetweenRays":
                            ANGLE_BETWEEN_RAY = StringAndNumberConversion.getOnlyIntegerNumber(variableValue, ' ');
                            countVariable++; 
                            break;
                        case "AntennaType":
                            ANModel = variableValue;
                            countVariable++;
                            break;
                        case "MaxReflection":
                            MAX_REFLECTIONS = StringAndNumberConversion.getOnlyIntegerNumber(variableValue, ' ');
                            countVariable++;
                            break;
                        case "MaxDistance":
                            MAX_DISTANCE = StringAndNumberConversion.getOnlyIntegerNumber(variableValue, ' ');
                            countVariable++;
                            break;
                        default:
                            //This default is for debugging purpose. If this variable name did not match any of the existing variables name. 
                            string errorMsg = "Error: " + variableName + "did not match one of the variables in ray tracer";
                            m_commsMod.DispatchReply(scriptID, 1, "Error: " + errorMsg, "");
                            m_log.DebugFormat("[RAY TRACER INIT] " + variableName + " did not match one of the variables in ray tracer");
                            break;
                    }//switch
                }//if

                //This else is purely for the purpose of debugging purpose. It only happens when the string doesn't 
                //contain both variable and its value, ie, not in this formar -> var=10, frequency=20
                else

                {
                    string errorMsg = "Error: " + variableNameAndValueToken[0] + "has length != 2";
                    m_commsMod.DispatchReply(scriptID, 1, "Error: " + errorMsg, "");
                }//else
            }//foreach

            return countVariable;
        }//initialiseVariables
        /// <summary>
        /// To find transmitter and receiver in the world.
        /// </summary>
        public void PostInitialise()
        {
            //Get all the entities in the world
			try { m_prims = m_scene.GetEntities(); } catch(Exception ex){ }

            //Initialise transmitter and receiver.
            if (!findTransmitterAndReceiver())
            {
                m_log.DebugFormat("[Ray Tracer PostInit] Transmitter and/or receiver not Found!");
                throw new Exception("Cannot find either Transmitter Tx or Receiver Ry");
            }

            //Initialise worldObjects. WorldObjects contains all the parts of the objects in the world which
            //the distance from itself to the transmitter is less than the MAX_DISTANCE. This is to reduce the
            //number of parts that we have to look at, i.e. reduces the computations time to find reflections. 

            worldObjects = new List<SceneObjectPart>();
            for (int i = 0; i < m_prims.Length; i++)
            {
                if (m_prims[i] is SceneObjectGroup)
                {
                    SceneObjectGroup sog = (SceneObjectGroup)m_prims[i];
                    sog.ForEachPart(delegate(SceneObjectPart part)
                    {
                        if (Vector3.Distance(part.AbsolutePosition, transmitter.RootPart.AbsolutePosition) <= MAX_DISTANCE || part.Name.CompareTo("Ry") == 0)
                        {
                            worldObjects.Add(part);
                        }
                    });
                }
            }

            //rayTraceFromTransmitterBrutefoce();
            getRaysPath();
            //testPoint();
        }
        /// <summary>
        /// Find if transmitter and receiver exist by checking all the objects in the world name. 
        /// Transmitter = Tx, Receiver = Ry.
        /// </summary>
        /// <returns></returns>
        bool findTransmitterAndReceiver()
        {
			try{
            EntityBase[] prims = m_scene.GetEntities();
			
            m_log.DebugFormat("[BARE BONES NON SHARED] Found {0} Entities!", prims.Length);
				
			//For each entities in the world, check if they are a transimitter Tx or a receiver Ry. 
            //Return true if both are true. 
            foreach (EntityBase prim in prims)
            {
                if (prim.Name.CompareTo("Tx") == 0)
                {
                    m_log.DebugFormat("[BARE BONES NON SHARED] Found the transmitter!");
                    transmitter = (SceneObjectGroup)prim;
                }
                if (prim.Name.CompareTo("Ry") == 0)
                {
                    m_log.DebugFormat("[BARE BONES NON SHARED] Found the Receiver!");
                    receiver = (SceneObjectGroup)prim;
                   
                }

            }
		}
			catch(Exception ex)
			{
				
			}
            return transmitter != null && receiver != null;
        }
        /// <summary>
        /// Find a point on a prim which is the reflection point of 2 points (pointFrom and pointTo). 
        /// This method uses the concept of "angle of incident = angle of rreflection" then solve
        /// that equation. 
        /// </summary>
        /// <param name="pointFrom">Source</param>
        /// <param name="pointTo">Target</param>
        /// <param name="part">a prim which is used as a reflection surface</param>
        /// <returns></returns>
        public ReflectionPoint findReflectionPoint(Vector3 pointFrom, Vector3 pointTo, SceneObjectPart part)
        {
            float x = 0, y = 0, z = 0;
            bool xIsZero = true, yIsZero = true, zIsZero = true;

            //Get a vector from start to the prim absolute position. Use that vector to test intersection
            //and get the normal of the prim. 

            Vector3 direction = part.AbsolutePosition - pointFrom;
            EntityIntersection intersection = part.TestIntersectionOBB(new Ray(pointFrom, direction), part.ParentGroup.GroupRotation, true, false);
            
            //Return false if the ray hits nothing.
            if (!intersection.HitTF)
                return new ReflectionPoint();

            if (intersection.normal.X != 0) { xIsZero = false; }
            if (intersection.normal.Y != 0) { yIsZero = false; }
            if (intersection.normal.Z != 0) { zIsZero = false; }


            //Note: We can get rid of the first three if(else) statement below. But for computation result, 
            //it is better to use them as the 'last else' statement is quite computationally intensive. 
            
            if(!xIsZero && yIsZero && zIsZero) //{1, 0, 0}
            {
                x = intersection.ipoint.X;
                y = solvePointEquation(pointFrom.Y, pointTo.Y, x, pointFrom.X, pointTo.X);
                z = solvePointEquation(pointFrom.Z, pointTo.Z, x, pointFrom.X, pointTo.X);
            }
            else if(xIsZero && !yIsZero && zIsZero) //{0, 1, 0}
            {
                y = intersection.ipoint.Y;
                x = solvePointEquation(pointFrom.X, pointTo.X, y, pointFrom.Y, pointTo.Y);
                z = solvePointEquation(pointFrom.Z, pointTo.Z, y, pointFrom.Y, pointTo.Y);
            }
            else if (xIsZero && yIsZero && !zIsZero) //{0, 0, 1}
            {
                z = intersection.ipoint.Z;
                x = solvePointEquation(pointFrom.X, pointTo.X, z, pointFrom.Z, pointTo.Z);
                y = solvePointEquation(pointFrom.Y, pointTo.Y, z, pointFrom.Z, pointTo.Z);
            }
            
            else if (xIsZero && yIsZero && zIsZero)
            {
                throw new Exception("There is no such normal vector which has x, y, and z = 0");
            }

            //else create a virtual enviroment where the reflection plane has a normal to be x-axis.
            //Find the reflection point on that virtual plane, then rotate it back to map the prim surface.

            else
            {
                //Initialise all the required rotation variables

                Quaternion partRotation = Vector3.RotationBetween(intersection.normal, new Vector3(1, 0, 0));
                Quaternion inverseRotation = Quaternion.Inverse(partRotation);
                Matrix4 partRotationM = Matrix4.CreateFromQuaternion(partRotation);
                Matrix4 inverseRotationM = Matrix4.CreateFromQuaternion(inverseRotation);

                //Direction vectors from prim absolute position to pointFrom, pointTo, and the intersection point.

                Vector3 newPointFrom = pointFrom - part.AbsolutePosition;
                Vector3 newPointTo = pointTo - part.AbsolutePosition;
                Vector3 newIntersection = intersection.ipoint - part.AbsolutePosition;

                //Rotate those directions vectors so that they map on a plane where normal = x-axis

                newPointFrom = Vector3.Transform(newPointFrom, partRotationM);
                newPointTo = Vector3.Transform(newPointTo, partRotationM);
                newIntersection = Vector3.Transform(newIntersection, partRotationM);

                //Convert those directions vectors back into a point

                newPointFrom += part.AbsolutePosition;
                newPointTo += part.AbsolutePosition;
                newIntersection += part.AbsolutePosition;

                //Now we calculate the relfection point by solving the equation.

                x = newIntersection.X;
                y = solvePointEquation(newPointFrom.Y, newPointTo.Y, x, newPointFrom.X, newPointTo.X);
                z = solvePointEquation(newPointFrom.Z, newPointTo.Z, x, newPointFrom.X, newPointTo.X);

                //Rotate the reflection point back to map the original prim surface.

                Vector3 virtualReflectionPoint = new Vector3(x, y, z) - part.AbsolutePosition;
                virtualReflectionPoint = Vector3.Transform(virtualReflectionPoint, inverseRotationM);
                virtualReflectionPoint += part.AbsolutePosition;

                //Set result x, y and z.

                x = virtualReflectionPoint.X;
                y = virtualReflectionPoint.Y;
                z = virtualReflectionPoint.Z;
            }

            //Check if the found reflection point (x, y, and z) is actually on the prim surface. 
            //If yes then return that point and true. If not then return point(0, 0, 0) and false;

            ReflectionPoint reflectionPoint = new ReflectionPoint(new Vector3(x, y, z), true);
            if (checkPointIntersectPrim(reflectionPoint.reflectionPoint, part, 0.05f)) 
            {
                reflectionPoint.surfaceMaterial = part.Material;
                return reflectionPoint; 
            }
            else { return new ReflectionPoint(); }
        }
        /// <summary>
        /// A very specific method used to assist findReflectionPoint(). It is used to solve an equation
        /// of when given a plane found, find another point. 
        /// Please use TROVE document as this might be very confusing
        /// </summary>
        public float solvePointEquation(float Tx, float Rx, float y, float Ty, float Ry)
        {
            // Here is the format
            //
            //       x - Tx             Rx - x
            //       ------     =       ------
            //       y - Ty             y - Ry
            //
            // where x is unknown. 

            float leftDenominator = y - Ty;
            float rightDenominator = y - Ry;

            //re-arrange equation and compute x
            return (((rightDenominator * Tx) + (leftDenominator * Rx)) / (rightDenominator + leftDenominator));

        }
        /// <summary>
        /// A point on a prim which is the reflection point of another 2 points. 
        /// It also contains variable 'found' which indicates whether if this reflection point
        /// exists. (it found = false, then don't use it)
        /// </summary>
        /// <summary>
        /// Delete all the object in the world whose name = Ray
        /// </summary>
        public void deleteRays()
        {
			try{
            EntityBase[] R_prims = m_scene.GetEntities();
            m_log.DebugFormat("[BARE BONES NON SHARED] Found {0} Entities!", R_prims.Length);

            //For each prim in the world, if their name is Rays, then delete them. 
            foreach (EntityBase prim in R_prims)
            {
                if (prim.Name.CompareTo("Rays") == 0)
                {
                    m_scene.DeleteSceneObject((SceneObjectGroup)prim, false);
                }
              
            }
            m_log.DebugFormat("[BARE BONES NON SHARED] Delete all Rays in scene");
			}
			catch(Exception ex)
			{
			}

        }
        public bool checkToken(string token, EntityBase prim)
        {

            //Get all tokens from the name
            string[] tokens = prim.Name.Split('_');
            //For each of the token if it matches then return true
            foreach (string t in tokens)
            {   //If matches, then return true
                if (t.CompareTo(token) == 0)
                    return true;
            }//foreach
            return false;
        }
        /// <summary>
        /// For every ray generated by the transmitter, trace it and check if it will be received by the transmitter 
        /// or not.
        /// </summary>
        void startRayTracerBrutefoce()
        {
            m_log.DebugFormat("[BARE BONES NON SHARED] Started Raytracing!");

            float lat, lon;
            List<PathFromTxToRy> rays = new List<PathFromTxToRy>();

            //For every lon and lat increase by ANGLE_BETWEEN_RAY
            for (lon = 0; lon < 360; lon += ANGLE_BETWEEN_RAY)
            {
                //m_log.DebugFormat ("[BARE BONES NON SHARED] Raytracing longtitude {0}!", lon);
                m_log.DebugFormat("[Ray Tracer] Raytracing {0}/360", lon);

                for (lat = 0; lat < 360; lat += ANGLE_BETWEEN_RAY)
                {
                    Vector3 dir = new Vector3();
                    double lonr = lon * DEG_TO_RAD;
                    double latr = lat * DEG_TO_RAD;

                    dir.X = (float)(Math.Cos(latr) * Math.Sin(lonr));
                    dir.Y = (float)(Math.Cos(latr) * Math.Cos(lonr));
                    dir.Z = (float)(Math.Sin(latr));
                    dir.Normalize();
                   
                    PathFromTxToRy path = new PathFromTxToRy(this, transmitter.AbsolutePosition, dir);
                    rays.Add(path);
                    //Thread worker = new Thread(reflections.followRayReflections);
                    //worker.Start();

                    //path.followRayReflections();
                    //while (worker.IsAlive);
                }
            }//for
            //For all the rays those we have computed their reflections, if they hit the receiver, then add them to hits. 
            foreach (PathFromTxToRy path in rays)
            {
                if (path.reachesReceiver)
                {
                    //m_log.DebugFormat ("[BARE BONES NON SHARED] Found a hitting ray {0}, reflections {1}!", reflection.direction, reflection.path.Count - 2);

                    hits[path.getNoOfReflection()].Add(path);
                }//if

            }//foreach

            m_log.DebugFormat("[RayTracerBrutefoce] Finnished Raytracing!");
        }
        /// <summary>
        /// Find path from line of sight to Max reflection. 
        /// Use the prims to determine which points to reflect,
        /// using the concept of angle of incident = angle of reflection,
        /// then solve the equation.
        /// </summary>
        void startRayTracerDirectMap()
        {
            //From 0 reflections to max reflections, find (up to) max number of path 

            for (int i = 0; i < MAX_REFLECTIONS; i++)
            {
                //hits[i] = getListOfDirectMapReflection();
            }//for
        }
        /// <summary>
        /// Stand for "DirectMap 0 reflection". Find 0 reflection(line-of-sight).
        /// Also do a check if there is an object between line of sight. If yes, then 
        /// return null, i.e. there is no line-of-sight between transmitter and the receiver.
        /// </summary>
        /// <returns>Line-of-sight path from Tx or Ry</returns>
        List<PathFromTxToRy> DM0Ref()
        {
            // My assumption is that if there is an object in between the line of sight, the signal will not 
            // penetrate through it therefore, there will be no line of sight. 

            //Test if the line of sight hit anything(object) before it hitting the receiver

            Vector3 lineOfSightDirection = receiver.RootPart.AbsolutePosition - transmitter.RootPart.AbsolutePosition;
            Ray lineOfSight = new Ray(transmitter.RootPart.AbsolutePosition, lineOfSightDirection);
            float distanceFromTxToRy = 0;
            //Make this big so that it can get smaller. If make it = 0, then it will not change.
            float distanceFromTxToClosestPrim = 10000000; 

            //For every object in the world, test if the line-of-sight intersects it. If yes, then check if
            //the distance is less than the direct distance from Tx to Ry. If yes then there is no line of sight.
            //as it has been blocked by other object. 

            worldObjects.ForEach(delegate(SceneObjectPart part)
            {
                EntityIntersection intersection = part.TestIntersectionOBB(lineOfSight, part.ParentGroup.GroupRotation, true, false);
                if (part.Name.CompareTo("Ry") == 0)
                {
                    distanceFromTxToRy = Vector3.Distance(transmitter.RootPart.AbsolutePosition, intersection.ipoint);
                }
                else if (intersection.HitTF && (part.Name.CompareTo("Tx") != 0))
                {
                    float distance = Vector3.Distance(intersection.ipoint, transmitter.RootPart.AbsolutePosition);
                    if (distance < distanceFromTxToClosestPrim)
                    {
                        distanceFromTxToClosestPrim = distance;
                    }//if
                }//else
            });//ForEach

            //If there is a line of sight
            if (distanceFromTxToRy < distanceFromTxToClosestPrim)
            {
                List<PathFromTxToRy> pathList = new List<PathFromTxToRy>();
                Vector3 fakeDirection = new Vector3();
                PathFromTxToRy pathFromTxToRy = new PathFromTxToRy(this, transmitter.RootPart.AbsolutePosition, fakeDirection);
                pathFromTxToRy.addNextPoint(receiver.RootPart.AbsolutePosition, receiver.RootPart.Material);
                pathList.Add(pathFromTxToRy);
                return pathList;

            }
            else //There is no line of sight
            {
                return null;
            }
        }
        List<PathFromTxToRy> DM1Ref()
        {
            List<PathFromTxToRy> pathList = new List<PathFromTxToRy>();
            worldObjects.ForEach(delegate(SceneObjectPart part)
            {
                ReflectionPoint reflectedPoint = findReflectionPoint
                    (transmitter.RootPart.AbsolutePosition, receiver.RootPart.AbsolutePosition, part);
                if (reflectedPoint.found)
                {
                    PathFromTxToRy newPath = new PathFromTxToRy(this, transmitter.RootPart.AbsolutePosition, new Vector3());
                    newPath.addNextPoint(reflectedPoint.reflectionPoint, reflectedPoint.surfaceMaterial);
                    newPath.addNextPoint(receiver.RootPart.AbsolutePosition, receiver.RootPart.Material);
                    pathList.Add(newPath);
                }//if
            });//forEachPart
            return pathList;
        }
        /// <summary>
        /// Apply Snells law to calculate the angle of refraction. 
        /// </summary>
        /// <param name="incidentAngle">Angle of incident in radian</param>
        /// <param name="refIndex1">Refractive index of medium 1</param>
        /// <param name="refIndex2">Refractive index of medium 2</param>
        /// <returns>angle of refrection or reflection in radian</returns>
        /// <author> Mona </author>
        double getRefAngle(double incidentAngle, double refIndex1, double refIndex2)
        {
            //          sin(θ1)         v1           n2
            //          -----      =   ----    =    ----
            //          sin(θ2)         v2           n1

            // where θ1 = incident angle, θ2 = refracted angle, v = velocity of light going 
            //through a certain medium n = refrected index of a certain medium.

            double refractedAngle = 0;
            refractedAngle = Math.Asin((refIndex1 * incidentAngle) / refIndex2);
            return refractedAngle;
        }
        /// <summary>
        /// Get the angle of incidence cosine when the incidence vector given and the plane normal.
        /// </summary>
        /// <param name="ray"></param>
        /// <param name="normal"></param>
        /// <returns></returns>
        public static float getAngleOfIncidenceCos(Vector3 ray, Vector3 normal)
        {
            ray.Normalize();
            normal.Normalize();

            return Vector3.Dot(ray, normal);
        }
        /// <summary>
        /// Get a reflected ray from a given ray and the normal of the surface. 
        /// First calculate an angle different between normal and the surface. 
        /// Second, create a new ray deriving from rotate the normal using the angle found in part 1
        /// Third, negate that new ray as it is pointing to the opposite direction
        /// </summary>
        /// <param name="ray">in-coming ray</param>
        /// <param name="normal">normal of the surface</param>
        /// <returns></returns>
        public  Vector3 getReflectedRay(Vector3 ray, Vector3 normal)
        {
            Quaternion rotation = Vector3.RotationBetween(ray, normal);
            return Vector3.Negate(Vector3.Transform(normal, Matrix4.CreateFromQuaternion(rotation)));
        }
        /// <summary>
        /// Get 'all' possible path from the transmitter to the receiver
        /// </summary>
        public void getRaysPath()
        {
        }
        /// <summary>
        /// Draw a ray (which has a shape of rectangle but with thin y and z value) from 2 given points. 
        /// The ray is drawn on the mid point between the 2 given points then rotate around y-axis and z-axis
        /// to make the ray connect between 2 points. For more information, please have a look at online TROVE Developer Documentations.
        /// By Thanakorn Tuanwachat 07/2013
        /// </summary>
        /// <param name="startPoint">The point where the ray start</param>
        /// <param name="endPoint">The point where the ray end</param>
        public void drawPlaneRay(Vector3 startPoint, Vector3 endPoint)
        {
            //Set up parameters for drawing an object in the world. Width = 0.2 unit and depth = 0.01 unit.
            //Length of the ray is the distance from the two given points

            float rayWidth = 0.05f; 
            float rayDepth = 0.05f;

            //Distance and Mid-point between 2 points. vectorFromStartToEnd can be used to represent a distance 
            //from x.end to x.start, y.end to y.start, z.end to z.start

            double rayLength = (startPoint - endPoint).Length();
            Vector3 midPoint = (startPoint + endPoint) / 2;
            Vector3 vectorFromStartToEnd = endPoint - startPoint;
            Vector3 xAxis = new Vector3(1, 0, 0);

            //Angles for rotating the objects (dervied from x, y, and z distances)
            //See developer documentations for more details

            Quaternion rotation = Vector3.RotationBetween(xAxis, vectorFromStartToEnd);

            //Start drawing the ray

            Vector3 dimension = new Vector3((float)rayLength, (float)rayWidth, (float)rayDepth);
            addObjectToTheWorld("Rays", midPoint, dimension, rotation, PrimType.Cylinder, startPoint);


        }
        /// <summary>
        /// Add a given object to the world. If you prefer argument to use default value, when pass it as null. 
        /// *There is 1 compulsory fields which is position of the object. The rest are optionals. 
        /// By Thanakorn Tuanwachat 07/2013
        /// </summary>
        /// <param name="name">Name of this object. Use default value "primative" if null is given</param>
        /// <param name="position">"Vector(x y z) where x, y, and z represent the coordinates in the world"</param>
        /// <param name="dimension">"Vector(x, y, z) where x, y, and z represent the size of the object"</param>
        /// <param name="rotations">double(x, y, z) where x, y, and z represent angle of rotation from its axis in radian</param>
        /// <param name="primType">There are only 3 types which are Box, </param>
        public void addObjectToTheWorld(string name, Vector3 position, Vector3 dimension, Quaternion rotation, int primType, Vector3 transmitterPos)
        {
            //Generate a new UUID for this ray

            UUID rayUUID = UUID.Random();

            //Place an object into the world. It can either be Box, Sphere, or Cylinder. according to the given PrimType

            SceneObjectGroup sog;
            switch (primType)
            {
                case PrimType.Box:
                    sog = new SceneObjectGroup(new UUID(rayUUID), position, OpenSim.Framework.PrimitiveBaseShape.CreateBox());
                    break;
                case PrimType.Sphere:
                    sog = new SceneObjectGroup(new UUID(rayUUID), position, OpenSim.Framework.PrimitiveBaseShape.CreateSphere());
                    break;
                case PrimType.Cylinder:
                    sog = new SceneObjectGroup(new UUID(rayUUID), position, OpenSim.Framework.PrimitiveBaseShape.CreateCylinder());
                    break;
                default:
                    sog = new SceneObjectGroup(new UUID(rayUUID), position, OpenSim.Framework.PrimitiveBaseShape.CreateBox());
                    break;
            }//switch

            //Check if it is possible to set thses parameters. If not then use default value

            if(dimension != null)
            {
              sog.RootPart.Scale = dimension;
            }
            if(rotation != null)
            {
                sog.RootPart.UpdateRotation(rotation);
            }//if
            if(name != null)
            {
                sog.Name = name;
            }//if
            else
            {
                sog.Name = "Primative";
            }//else
            //Add this object to the scene.
            m_scene.AddNewSceneObject(sog, false);
            sog.ScheduleGroupForFullUpdate();
            sog.HasGroupChanged = true;
        }
        /// <summary>
        /// Check if a given point is within the rectangle boundary of a prim. 
        /// Note: This method works best with retangle object. 
        /// </summary>
        /// <param name="point">A point to be checked</param>
        /// <param name="prim">An object in the world</param>
        /// <param name="precision">Wrapper size around the object/prim in metre. If you don't understand then just use 0.05f</param>
        /// <returns></returns>
        public bool checkPointIntersectPrim(Vector3 point, SceneObjectPart prim, float precision)
        {
            //Offset is used to determined boundary. Boundary = mid-point +- offset.
            //Precision = 0 means the point is absolutely within the boundary. 
            //Increase in precision = allowing more error for 
            //the point to intersect the prim further. i.e. don't make it too big 
            //but I would not recommend 0 incase some rounding error 

            Vector3 offset = (prim.Scale / 2) + new Vector3(precision, precision, precision);
            Vector3 primPosition = prim.AbsolutePosition;
            Vector3 maxBoundary = primPosition + offset;
            Vector3 minBoundary = primPosition - offset;

            //At the moment, if the prim has been rotated, the point of intersection will not hit the boundary,
            //so we need to rotate the point to map it to the original prim where no rotation has been done
            //Do this by create a vector from the prim position to the intersection point, rotate that vector, then 
            //recalculate the intersection point. 

            Quaternion rotation = prim.RotationOffset * -1;
            Vector3 rotationVector = point - primPosition;
            rotationVector = Vector3.Transform(rotationVector, Matrix4.CreateFromQuaternion(rotation));
            rotationVector += primPosition;

            //Check if the intersection is within the boundary.

            if ((rotationVector.X >= minBoundary.X && rotationVector.X <= maxBoundary.X) &&
                (rotationVector.Y >= minBoundary.Y && rotationVector.Y <= maxBoundary.Y) &&
                (rotationVector.Z >= minBoundary.Z && rotationVector.Z <= maxBoundary.Z))
            {
                return true;
            }//if
            else
                return false;
        }
        public class ReflectionPoint
        {
            public Vector3 reflectionPoint;
            public bool found;
            public int surfaceMaterial;

            public ReflectionPoint()
            {
                found = false;
            }
            public ReflectionPoint(Vector3 _reflectionPoint, bool _found)
            {
                reflectionPoint = _reflectionPoint;
                found = _found;
            }
        }
        public class Ray2
        {
            public Vector3 startPoint;
            public Vector3 endPoint;
            public double maxPower;
            public string powerUnit;
            public double minPower;

            /// <summary>
            /// 
            /// </summary>
            /// <param name="_ray"> A ray from starting point and its direction</param>
            /// <param name="_maxPower">The maximum transmittion power of the stating point</param>
            public Ray2(Vector3 _startPoint, Vector3 _endPoint, double startPower, string _powerUnit)
            {
                startPoint = _startPoint;
                endPoint = _endPoint;
                maxPower = startPower;
                powerUnit = _powerUnit;
                minPower = maxPower - RadioPower.CalculatePathloss(Vector3.Distance(startPoint, endPoint), maxPower.ToString(), powerUnit);
            }//constructor

            /// <summary>
            /// Get a power in dBW at a given point. Calculate the distance from the start point to
            /// the given point then use that distance to calculate the new power. 
            /// </summary>
            /// <param name="point"></param>
            /// <returns></returns>
            public double getStrengthAt(Vector3 point)
            {
                return 0;
            }//getStrengthAt

            /// <summary>
            /// Calculate and return the left-over power after the reflection at the 
            /// end point of this ray.
            /// </summary>
            /// <param name="primMaterial">The material which reflecting this ray</param>
            /// <returns>Left over power in dBW</returns>
            public double getStrengthAfterReflection(Vector3 nextPoint, int primMaterial)
            {
                //To find the angle between 2 vectors
                //
                //    A.B
                //  ------  = cos(θ)
                //  |A||B|

                Vector3 ray1 = startPoint - endPoint;
                Vector3 ray2 = nextPoint - endPoint;
                double airRefractiveIndex = RefrectiveIndex.AIR;
                double surfaceRefractiveIndex = RefrectiveIndex.getRefractiveIndex(primMaterial);

                //Calculate angle or incident, and reflection/refraction angle. 
                RayTracer rayTracerModel = new RayTracer();
                double incidentAngle = Math.Acos(Vector3.Dot(ray1, ray2) / (ray1.Length() * ray2.Length()));
                double reflectionAngle = rayTracerModel.getRefAngle(incidentAngle, airRefractiveIndex, surfaceRefractiveIndex);

                //Calculate and return reflection/refraction loss

                return (minPower - RadioPower.ComputeRefloss(airRefractiveIndex, surfaceRefractiveIndex, incidentAngle, reflectionAngle));
            }
        }
        /// <summary>
        /// A path from Tx to Rx. A path can consist of 1 or more than 1 ray. Ray = a line from one point to another.
        /// </summary>
        public class PathFromTxToRy
        {
            //rays = a list of rays from Tx to Rx. PathFromTxToRy may have more than one ray due to reflection. 

            public List<Ray2> rays; 
            public Vector3 transmitterPos;                      //Transmitter position
            public Vector3 direction;                           //Direction vector of the first ray (For BlindSearch)
            public bool reachesReceiver;                        //Has this path reached the reveicer?
            RayTracer rayTracerModel;                           //Ray tracer model. (The method used to create this object)
            Ray2 lastRay = null;                                //The current end/last ray of this path 

            public PathFromTxToRy(RayTracer parent, Vector3 _start, Vector3 _direction)
            {
                rayTracerModel = parent;
                direction = _direction;
                transmitterPos = _start;
                reachesReceiver = false;
            }
            /// <summary>
            /// Add a new reflection point or receiver point(destination) to this path
            /// </summary>
            /// <param name="nextPoint">the reflection point or receiver</param>
            /// <param name="primMaterial">the material of a prim which reflection point occur. If it is the 
            /// receiver, then just get the receiver material</param>
            public void addNextPoint(Vector3 nextPoint, int primMaterial)
            {
                //If there is a last ray then uses its endPoint as a start point for this new ray

                if (lastRay != null)
                {
                    double newStartPower = lastRay.getStrengthAfterReflection(nextPoint, primMaterial);
                    Ray2 ray = new Ray2(lastRay.endPoint, nextPoint, newStartPower, lastRay.powerUnit);
                    rays.Add(ray);
                    lastRay = ray;
                }
                else //This is the first ray starting from the transmitter to the given 'nextPoint'
                {
                    Ray2 firstRay = new Ray2(transmitterPos, nextPoint, rayTracerModel.runningPowerRT, rayTracerModel.runningPowerRTUnit);
                    rays.Add(firstRay);
                    lastRay = firstRay;
                }
            }

            /// <summary>
            /// Get the number of reflection. Number of reflection = total number of rays -1.
            /// </summary>
            /// <returns></returns>
            public int getNoOfReflection()
            {
                return rays.Count() - 1;
            }
        }//PathFromTxToRy object.
    }//RayTracer

}//namespace
